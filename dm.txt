import pandas as pd
import itertools

transaction_list = [
    ['I1','I2','I5'],
    ['I2','I4'],
    ['I2','I3'],
    ['I1','I2','I4'],
    ['I1','I3'],
    ['I2','I3'],
    ['I1','I3'],
    ['I1','I2','I3','I5'],
    ['I1','I2','I3']
]

min_support_count = 2
min_confidence = 0.285

unique_items = set()
for transactions in transaction_list:
  unique_items = unique_items.union(set(transactions))

c1 = {tuple([item]): 0 for item in unique_items}
for item in unique_items:
  for transactions in transaction_list:
    if set(tuple([item])).issubset(transactions):
      c1[tuple([item])]+=1
c1_keys = sorted(c1.keys(), key=lambda x:x[0][1])
l1 = {keys: c1[keys] for keys in c1_keys if c1[keys] >= min_support_count}
print(c1)
print(l1)

def candidate_set_generation(lk_1: list, k: int):
  lk={}
  for iter1 in range(0, len(lk_1)):
    for iter2 in range(iter1+1, len(lk_1)):
      flag=0
      for j in range(k-2):
        if lk_1[iter1][j] != lk_1[iter2][j]:
          flag=1
          break
      if flag == 0:
        lk[ tuple([ *lk_1[iter1], lk_1[iter2][len(lk_1[iter2]) - 1] ]) ] = 0
  return lk

def lk_1_subsets(key: list, k: int):
  return list(itertools.combinations(key, k))


def l_set_generation(transaction_list: list, ck: list, lk_1: list, k: int, min_support_count: int):
  for key in ck.keys():
    pruned=False
    subsets = lk_1_subsets(key, k-1)
    for subset in subsets:
      if lk_1.get(subset) is None:
        pruned = True
        print(f'pruned: {key}')
        break
    
    if pruned:
      continue
    
    for transaction in transaction_list:
      if set(key).issubset(transaction):
        ck[key]+=1
    
  return {key: value for key, value in ck.items() if value>=min_support_count}


c2 = candidate_set_generation(list(l1.keys()), k=2)
l2 = l_set_generation(transaction_list, c2, l1, k=2, min_support_count=min_support_count)

c3 = candidate_set_generation(list(l2.keys()), k=3)
l3 = l_set_generation(transaction_list, c3, l2, k=3, min_support_count=min_support_count)

def all_subsets(key, k):
  return [list(itertools.combinations(key, i)) for i in range(1, k)]

def association_rule_generator(lk: dict, all_l_before_k: list, k: int, min_confidence: int):
  for key, value in lk.items():
    subsets_list = all_subsets(key, k)
    for iter in range(len(subsets_list)):
      for subset in subsets_list[iter]:
        if value/all_l_before_k[iter][subset] >= min_confidence:
          print(f'{subset} -> {set(tuple(key)).difference(set(subset))} :: {value/all_l_before_k[iter][subset]}')

association_rule_generator(l3, [l1, l2], k=3, min_confidence=min_confidence)
association_rule_generator(l2, [l1], k=2, min_confidence=min_confidence)



