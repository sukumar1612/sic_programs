# -*- coding: utf-8 -*-
"""ir_lab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tr5tftNjsMN5ZLANux09-_aLrXGx287_
"""

import random
import numpy as np

"""Min Hashing"""

def init_input_matrix(input_matrix, bow):
  for idxb, b in enumerate(bow):
    for idxs, sx in enumerate(s):
      if b in sx:
        input_matrix[idxb][idxs] = 1

  return input_matrix

def jaccards_similarity(c1, c2):
  union = 0
  intersection = 0

  for x1, x2 in zip(c1, c2):
    if x1 or x2:
      union+=1
      if x1==x2:
        intersection+=1

  #print(f"{intersection}/{union}")
  return intersection/union

def hashing(input_matrix):
  random_number_lst = random.sample(range(len(input_matrix)), len(input_matrix))
  r_input_matrix = [input_matrix[i] for i in random_number_lst]

  flag = [-1 for _ in range(len(r_input_matrix[0]))]

  for idxs, sx in enumerate(r_input_matrix):
    for idxf, flg in enumerate(flag):
      if flg==-1 and r_input_matrix[idxs][idxf] == 1:
        flag[idxf] = idxs + 1

  return flag


def min_hashing(input_matrix, sample_size):
  signature_matrix = []
  for i in range(sample_size):
    signature_matrix.append(hashing(input_matrix))

  print("-----------signature-matrix----------")
  for i in signature_matrix:
    print(i)
  print("\n\n")

  sim_mat = [[1 for __ in range(len(input_matrix[0]))] for i in range(len(input_matrix[0]))]
  for i in range(len(input_matrix[0])):
    for j in range(i+1, len(input_matrix[0])):
      c1 = [signature_matrix[x][i] for x in range(len(signature_matrix))]
      c2 = [signature_matrix[x][j] for x in range(len(signature_matrix))]
      sim_mat[i][j] = jaccards_similarity(c1, c2)
      sim_mat[j][i] = sim_mat[i][j]

  print("-----------similarity-matrix----------")
  print()
  for idx in range(len(sim_mat)):
    print(f"   s{idx+1}\t\t", end='')
  print("")

  for idx, sx in enumerate(sim_mat):
    print(f"s{idx+1} ", end='')
    for i in sx:
      print(f"{i:.2f}\t\t", end='')
    print("\n")
  print("\n\n")
  return sim_mat

def doc_to_s(document, shingle_size: int = 1):
  unique_shingles = []
  doc_new = []
  for doc, val in document.items():
    vals = val.split(' ')
    doc_new.append([])
    for v in range(len(vals) - shingle_size + 1):
      shingle = ' '.join(vals[v: v+shingle_size])
      doc_new[-1].append(shingle)
      if shingle not in unique_shingles:
        unique_shingles.append(shingle)

  print(unique_shingles)
  s = []
  for doc, val in document.items():
    s.append([])
    for idxu, us in enumerate(unique_shingles):
      if us in val:
        s[-1].append(idxu)

  for sx in s:
    print(sx)
  return s

s1 = ["A", "B", "F", "G"]
s2 = ["C", "D", "E"]
s3 = ["A", "F", "G"]
s4 = ["B", "C", "D", "E"]

s = [s1, s2, s3, s4]

bow = set([_ for sx in s for _ in sx])
bow = list(sorted(list(bow)))
bow

input_matrix = [[0 for _ in s] for __ in bow]

input_matrix = init_input_matrix(input_matrix, bow)

for i in input_matrix:
    print(i)

min_hashing(input_matrix, 5)

document = {"document1":"He moved from London Ontario to London England",
               "document2":"He moved from London England to London Ontario",
               "document3":"He moved from England to London Ontario"}

s = doc_to_s(document, shingle_size=3)

bow = set([_ for sx in s for _ in sx])
bow = list(sorted(list(bow)))
bow

input_matrix = [[0 for _ in s] for __ in bow]

init_input_matrix(input_matrix, bow)

min_hashing(input_matrix, 3)

"""

```
# This is formatted as code
```

Page Rank(Query independent score)"""

adjacence_matrix = [
    [0, 1, 0],
    [1, 0, 1],
    [0, 1, 0]
]
alpha = 0.5

def convert_to_hyperlink_matrix(adjacence_matrix):
  row_sum = []
  for i in adjacence_matrix:
    sum1 = 0
    for j in i:
      sum1+=j
    row_sum.append(sum1)

  hyperlink_matrix = []
  for idxr, rsum in enumerate(row_sum):
    hyperlink_matrix.append([])
    for j in range(len(adjacence_matrix[0])):
      hyperlink_matrix[-1].append(adjacence_matrix[idxr][j]/rsum)

  return hyperlink_matrix

n=len(adjacence_matrix)
hyperlink_matrix = np.array(convert_to_hyperlink_matrix(adjacence_matrix))
hyperlink_matrix

hyperlink_matrixG = alpha*(hyperlink_matrix) + (1-alpha)*(1/n)
hyperlink_matrixG

pr0 = np.array([1/n for i in range(n)])
pr0

def calc_prk(pr0, hyperlink_matrix, k):
  pr=pr0

  for i in range(k):
    pr=np.matmul(pr, hyperlink_matrix)

  return pr

calc_prk(pr0, hyperlink_matrixG, 1)

calc_prk(pr0, hyperlink_matrixG, 8)

calc_prk(pr0, hyperlink_matrixG, 1000)

pk1000 = calc_prk(pr0, hyperlink_matrixG, 100000)
sum(pk1000)

"""HITS Algorithm"""

adjacence_matrix = np.array([
    [0, 0, 0, 1, 0, 0, 0, 0],
    [0, 0, 1, 0, 1, 0, 0, 0],
    [1, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 1, 0, 0, 0, 0, 0],
    [0, 1, 1, 1, 0, 1, 0, 0],
    [0, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 0],
    [1, 0, 0, 0, 0, 0, 0, 0]
])

h0 = np.array([1 for _ in range(len(adjacence_matrix))]).T
a0 = np.array([1 for _ in range(len(adjacence_matrix))]).T

def check_convergence(hn_1, hn, an_1, an):
  diff_hn = hn - hn_1
  diff_an = an - an_1

  for h in diff_hn:
    if abs(h) > 0.01:
      return False

  for a in diff_an:
    if abs(a) > 0.01:
      return False

  return True

def calc_hits(adjacence_matrix, h0, a0, k):
  an = a0
  an_1 = an
  hn = h0
  hn_1 = hn

  for i in range(k):
    hn = np.matmul(adjacence_matrix, an_1)
    an = np.matmul(adjacence_matrix.T, hn_1)

    hn = hn*(1/sum(hn))
    an = an*(1/sum(an))

    print(check_convergence(hn_1, hn, an_1, an) and i!=0, i)
    if check_convergence(hn_1, hn, an_1, an) and i!=0:
      return hn_1, an_1
    hn_1 = hn
    an_1 = an

  return hn, an

hn, an = calc_hits(adjacence_matrix, h0, a0, 2)

hn, an = calc_hits(adjacence_matrix, h0, a0, 10000)

def rank_hits(hn, an):
  dct = {i: chr(ord('A') + i) for i in range(len(hn))}

  hn_n = sorted([[v, chr(ord('A') + i)] for i, v in enumerate(hn)], key=lambda x: -x[0])
  an_n = sorted([[v, chr(ord('A') + i)] for i, v in enumerate(an)], key=lambda x: -x[0])


  print("hub order\n")
  for h in hn_n:
    print(f"{h[1]}: {h[0]}")

  print("\n\nauthority order\n")
  for a in an_n:
    print(f"{a[1]}: {a[0]}")

rank_hits(hn, an)

