# -*- coding: utf-8 -*-
"""final_only_prob_mytake.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hjMNVtsr089wT9PNC8km7D-aE0V5MPZE

Silver Meal
"""

input_data = [
    [1, 10, 20, 1],
    [2, 15, 17, 1],
    [3, 7, 10, 1],
    [4, 20, 18, 3],
    [5, 13, 5, 1],
    [6, 25, 50, 1]
]

#Pi Di Ki hi

def silver_meal(input_data):
  table = []
  n = len(input_data) + 1

  i = 1
  while(i<n-1):
    table.append([])
    for t in range(i, n):
      period = input_data[t-1][0]
      dt = input_data[t-1][1]
      kt = input_data[t-1][2]
      ht = sum([input_data[x][3] for x in range(t-1)])

      TC = kt if i == t else table[-1][-1][2] + ht * dt
      TCU = TC/(t - i + 1)

      table[-1].append([period, dt, TC, TCU])
      print([period, dt, TC, TCU])

      if len(table[-1]) >=3:
        TCUt_1 = table[-1][-3][-1]
        TCUt = table[-1][-2][-1]
        TCUt_p_1 = table[-1][-1][-1]

        if TCUt_1 >= TCUt and TCUt <= TCUt_p_1:
          total_demand = [table[-1][x][1] for x in range(0, t-i)]
          print(f"The local minimum occurs at t*={t-1}, with demand {total_demand}")
          i = t
          break
      elif len(table[-1]) >=2:
        TCUt = table[-1][-2][-1]
        TCUt_p_1 = table[-1][-1][-1]

        if TCUt <= TCUt_p_1:
          total_demand = [table[-1][x][1] for x in range(0, t-i)]
          print(f"The local minimum occurs at t*={t-1}, with demand {total_demand}")
          i = t
          break

silver_meal(input_data)

"""Probabilitized EOQ"""

import numpy as np
import scipy.stats as st

D=200 #N(D,sigma) given in question
sig = 20
h = 0.04
K = 100
L = 7
alpha = 0.02

y_star = math.sqrt(2*K*D/h)

t_star = y_star/D

Le=0
if L>t_star:
  Le =  L - math.floor(L/t_star)*t_star

mu_l = D*Le
sigma_l = math.sqrt(Le*sig*sig)

K_alpha = st.norm.ppf(1 - alpha) #find using alpha value
B = round(sigma_l*K_alpha)
print("The optimal inventory policy is order",y_star,"units when inventory drops to",B+mu_l,"units")

"""probabilistic EOQ"""

import sympy as sp
import math

x, R, yi = sp.symbols('x R yi')

D = 1000
K = 100
h = 2
p = 10

func1 = (x-R)/100
a = R
b = 100
S = sp.integrate(func1, (x, a, b))
print(f"Result: {S}")

func2 = 1/100
lhs = sp.integrate(func2,(x,a,b))
rhs = (h*yi)/(D*p)
Rsolution = sp.solve(sp.Eq(lhs, rhs), R)
print(f"Solution for R: {Rsolution}")

def iterations(Y_val,R_val,iter):
  print("iteration number is ",iter)
  prevY = Y_val
  prevR = R_val

  s_i = S.subs(R,R_val)
  print("The value of S is ",s_i)

  y_cur = math.sqrt((2*D*(K+(p*s_i)))/h)

  print("the value of y is ",y_cur)

  r_cur = Rsolution[0].subs(yi,y_cur)

  print("The value r is ",r_cur)

  if (prevY - y_cur) < 0.01 and (prevR - r_cur) < 0.01:
    print("\n")
    print("The y* value is ",y_cur)
    print("The R* value is ",r_cur)
    return

  else:
    iterations(y_cur,r_cur,iter+1)

#iteration 1
y1 = math.sqrt((2*D*K)/h)
R1 = Rsolution[0].subs(yi,y1)
print("iteration number is 1")
print("The value of y is ",y1)
print("The value of r is ",R1)

iterations(y1,R1,2)

"""NewsVendor Model"""

p=45 #penalty cost
h=25 #holding cost
mean=300
std=20

ratio=p/(p+h)

y_star = std*st.norm.ppf(ratio) + mean
np.ceil(y_star)

d = [200,220,300,320,340]
f_d = [0.1 ,0.2 ,0.4 ,0.2 ,0.1]

cdf = [sum(f_d[:i]) for i in range(1, len(f_d)+1)]

for idx, c in enumerate(cdf):
  if c>=ratio:
    print(f"y* = {d[idx]}")
    break

"""S-s model"""

h=2
p=18
print(p/(p+h))

import sympy as sy

d,x,ystar=sy.symbols('d x ystar')

pdlessthanystar=sy.integrate((1/60),(d,90,ystar))

pdlessthanystar

y_star=sy.solve(pdlessthanystar-p/(p+h),ystar)
y=sy.symbols('y')
S=int(y_star[0])
S

integral1=sy.integrate((1/60)*(y-d),(d,90,y))

integral1

integral2=sy.integrate((1/60)*(d-y),(d,y,150))

integral2

ECofy=h*integral1+p*integral2

K=10
solns=sy.solve(ECofy.subs(y,S)+K-ECofy,y)

ans=[]
for i in solns:
  if i>S:
    print(i,">S and discarded")
  else:
    ans.append(i)

ans

flag=0
for i in ans:
  if i>0:
    flag=1
if flag==0:
  print("No feasible value of s")

print("If x<{} order {}-x units".format(ans[0],S))
print("Else do not order")

solns

ECofy

