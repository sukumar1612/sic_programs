# -*- coding: utf-8 -*-
"""timeseries-mmlab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LJLD0vUVOpvw934s9bvy__32GxW8wQZL
"""

import pandas as pd
df=pd.read_csv('/content/drive/MyDrive/mmlab/TATAMOTORS.NS.csv')

df

import numpy as np

df.loc[:,'Close']

x = np.arange(len(df))  # x-axis values (e.g., months)
y = df.loc[:,'Close'].values           # y-axis values (e.g., stock prices)

import scipy.interpolate as interpolate
import matplotlib.pyplot as plt
f = interpolate.interp1d(x, y)
xnew = np.arange(0, len(df), 1)
ynew = f(xnew)   # use interpolation function returned by `interp1d`

plt.plot(x, y, 'o', xnew, ynew, '-')

plt.show()

predicted_mid_values=[]
for i in range(len(df)-1):
  predicted_mid_values.append(f(i+0.5))

len(predicted_mid_values)

import re
data=pd.read_csv('/content/drive/MyDrive/mmlab/daily_data.csv')
import pandas as pd
data['Date'] = pd.to_datetime(data['Date'])
g = data.groupby(pd.Grouper(key='Date', freq='M'))
actual_values=[]

for gi,v in g:
  month=gi.month
  actual_values.append(v.iloc[15,4])
  #print(v.columns)
  #print(type(v),gi,month)

def err(interpolated,original):
  error=0
  for i,j in zip(original,interpolated):
    error+=(i-j)**2
  return error
err(actual_values[:119],predicted_mid_values)

print(len(actual_values),len(predicted_mid_values))

# Plot the arrays
plt.plot(actual_values[:119], label='actual')
plt.plot(predicted_mid_values, label='predicted')

# Add labels and legend
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.legend()

# Show the plot
plt.show()

"""## Quadratic fit

"""

f2 = interpolate.interp1d(x, y, kind = 'cubic')

print(f2(0),f2(1))

import scipy.interpolate as interpolate
import matplotlib.pyplot as plt
xnew = np.arange(0, len(df), 1)
ynew = f2(xnew)   # use interpolation function returned by `interp1d`

plt.plot(x, y, 'o', xnew, ynew, '-')

plt.show()

predicted_mid_values=[]
for i in range(len(df)-1):
  predicted_mid_values.append(f2(i+0.5))

err(actual_values,predicted_mid_values)

# Plot the arrays
plt.plot(actual_values, label='actual')
plt.plot(predicted_mid_values, label='predicted')

# Add labels and legend
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.legend()

# Show the plot
plt.show()

"""## Regression

"""

from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

regression_model = LinearRegression()
regression_model.fit(x.reshape(-1, 1), y)
y_predicted = regression_model.predict(x.reshape(-1, 1))
train_len=len(x)

y_predicted

import matplotlib.pyplot as plt
xnew = np.arange(0, len(df), 1)
plt.plot(x, y, 'o', xnew, y_predicted, '-')

plt.show()

err(actual_values,y_predicted)

# forecasting in 2023
import re
future_data=pd.read_csv('/content/drive/MyDrive/mmlab/TATAMOTORS-2023.csv')
import pandas as pd
expected_values=future_data['Close'].values

x_pred=np.arange(train_len,train_len+len(expected_values)).reshape((-1,1))
forecasted=regression_model.predict(x_pred)
x=np.arange(0,train_len+len(x_pred))

err(forecasted,expected_values)

y_line=np.concatenate([actual_values,expected_values])
x=np.arange(len(y_line))
plt.plot(x,y_line)
y_pred_line=np.concatenate([y_predicted,forecasted])
x=np.arange(len(y_pred_line))
plt.plot(x,y_pred_line, '-.')

"""### cubic regression

"""

import scipy.stats as stats
def t_test(predicted, actual):
    t_value, p_value = stats.ttest_ind(predicted, actual)
    return t_value

df_train=df[:-8]
df_test=df[-8:]
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
x=np.arange(len(df_train))
y=df_train.loc[:,'Low'].values
x_test=np.arange(len(df_test))
y_test=df_test.loc[:,'Low'].values

model = np.poly1d(np.polyfit(x,y, 3))
y_pred_cubic=model(x)
import matplotlib.pyplot as plt
plt.plot(x, y, '-', x, y_pred_cubic, '-')

plt.show()
y_test_predicted_cubic = model(x_test)
err(y_test_predicted_cubic,y_test)
t_test(y_test_predicted_cubic,y_test)

"""## ARMA,ARIMA"""

plt.plot(df['Date'],df['Close'])

!pip install --upgrade statsmodels

import statsmodels.graphics.tsaplots as tsaplots
tsaplots.plot_acf(df['Close'])

tsaplots.plot_pacf(df['Close'])

import math
from statsmodels.tsa.arima.model import ARIMA
t_l=math.floor(len(df)*0.8)
arma_mod20 = ARIMA(df.loc[:t_l,'Close'], order=(1, 1, 10)).fit()
y=arma_mod20.predict(start=0,end=t_l)
plt.plot(df.loc[:t_l,'Date'],y,color='r')
plt.plot(df.loc[:t_l,'Date'],df.loc[:t_l,'Close'])

y_pred=arma_mod20.predict(start=t_l+1,end=len(df))
x_pred=[i for i in range(len(df))]
#print(y_pred,y)
y_l=y.values.tolist()
y_pred_l=y_pred.values.tolist()
y_l.extend(y_pred)
ex_tot=df['Close']
print(y_l)
plt.plot(x_pred,y_l[:len(df)],c='r')
plt.plot(x_pred,df['Close'])