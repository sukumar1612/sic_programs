# -*- coding: utf-8 -*-
"""ca1_mytake.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ypH0JTfJeDjIzOOAz8B9xKBiEopY4w-e
"""

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.stattools import acf, pacf
from statsmodels.tsa.arima.model import ARIMA
import numpy as np

stock_data = pd.read_csv("/content/drive/MyDrive/IR/LAB_SHEET1/NSE-TATAGLOBAL.csv")

import yfinance as yf
tickerSymbol = "AAPL"

tickerData = yf.Ticker(tickerSymbol)
tickerDf = tickerData.history(period='1d', start='2021-1-1', end='2021-4-1')
tickerDf = tickerDf[['Close']]
tickerDf.head()

plt.figure(figsize=(10,4))
plt.plot(tickerDf.Close)
plt.title('Stock Price over Time (%s)'%tickerSymbol, fontsize=20)
plt.ylabel('Price', fontsize=16)
for year in range(2021,2022):
    plt.axvline(pd.to_datetime(str(year)+'-01-01'), color='k', linestyle='--', alpha=0.2)

acf = plot_acf(tickerDf.Close.diff().dropna())

pacf = plot_pacf(tickerDf.Close.dropna())

train_size = int(len(tickerDf)*0.7)
test_size = int(len(tickerDf)*0.3)

train_set = tickerDf[:train_size]
test_set = tickerDf[train_size:]
print(train_size)

arima_model = ARIMA(train_set.Close, order=(1, 0, 5)).fit()

arima_model.summary()

output = arima_model.forecast(steps=19)

output_df = pd.DataFrame(output)
output_df['Date'] = pd.to_datetime(test_set.index)
output_df['Close'] = output_df['predicted_mean']
output_df.set_index('Date', inplace=True)

plt.figure(figsize=(10, 4))
plt.plot(test_set[['Close']][:10])
plt.plot(output_df[['Close']][:10])
plt.legend(("Data", "Prediction"))
for year in range(2022,2022):
    plt.axvline(pd.to_datetime(str(year)+'-01-01'), color='k', linestyle='--', alpha=0.2)

"""Deseasonilize Data"""

plt.plot(tickerDf.Close)
plt.title('TATAGLOBAL deseasonalized', fontsize=16)
plt.plot()

from statsmodels.tsa.seasonal import seasonal_decompose

result_mul = seasonal_decompose(tickerDf.Close, model='multiplicative', period=30)
deseasonalized = tickerDf.Close.values / result_mul.seasonal

plt.plot(deseasonalized)
plt.title('TATAGLOBAL deseasonalized', fontsize=16)
plt.plot()

"""Autoregression"""

arima_model = ARIMA(train_set.Close, order=(1, 0, 5)).fit()

"""Moving Average"""

train_set.Close.tolist()

import pandas as pd

arr = [1, 2, 3, 7, 9]
window_size = 3
numbers_series = pd.Series(arr)
windows = numbers_series.rolling(window_size)
moving_averages = windows.mean()
moving_averages_list = moving_averages.tolist()
final_list = moving_averages_list[window_size - 1:]

plt.plot(final_list,c='r')
plt.plot(test_set.Close.tolist(), c='g')

"""MM1"""

arrival_rate = 1
inter_arrival_time = 1/arrival_rate
service_time = 1

arrival_time = np.random.exponential(inter_arrival_time, 100)
service_time = np.random.exponential(service_time, 100)

cumu_arrival_time = []
prev_time = 0
for time in arrival_time:
  prev_time+=time
  cumu_arrival_time.append(prev_time)

cust_waiting_time = 0
system_idle_time = cumu_arrival_time[0]

queue = [cumu_arrival_time[0]]
for i in range(1, len(cumu_arrival_time)):
  queue.append(max(service_time[i] + queue[i-1], cumu_arrival_time[i]))

  if service_time[i] + queue[i-1] > cumu_arrival_time[i]:
    cust_waiting_time += service_time[i] + queue[i-1] - cumu_arrival_time[i]
  elif service_time[i] + queue[i-1] < cumu_arrival_time[i]:
    system_idle_time += cumu_arrival_time[i] - service_time[i] + queue[i-1]

"""MM2"""

# @title Default title text
arrival_rate = 0.0625
inter_arrival_time = 1/arrival_rate
service_time = 8
n = 10**7
seconds = 10**7

arrival_time = np.random.exponential(inter_arrival_time, n)
cumu_arrival_time = []
prev_time = 0
for time in arrival_time:
  prev_time+=time
  cumu_arrival_time.append(prev_time)

cumu_arrival_time_int = [int(i)+2 for i in cumu_arrival_time]

service_time_int1 = [int(i)+1 for i in np.random.exponential(service_time, n)]
service_time_int2 = [int(i)+1 for i in np.random.exponential(service_time, n)]

queue = [cumu_arrival_time_int[0], cumu_arrival_time_int[1], cumu_arrival_time_int[2]]

serv1_k = 0
serv2_k = 0
arv_k = 3

server_1 = cumu_arrival_time_int[0] + service_time_int1[serv1_k]
server_2 = cumu_arrival_time_int[1] + service_time_int2[serv2_k]

cust_waiting_time = 0
system_idle_time = min(cumu_arrival_time_int[0], cumu_arrival_time_int[1])

for i in range(0, seconds):
  if server_1 <= i:
    if len(queue) == 0:
      system_idle_time+=1
      if i>=cumu_arrival_time_int[arv_k]:
        queue.append(cumu_arrival_time_int[arv_k])
        arv_k+=1
      continue

    server_1 = i + service_time_int1[serv1_k]
    cust_waiting_time += i + service_time_int1[serv1_k] - queue.pop(0)
    serv1_k+=1

  if server_2 <= i:
    if len(queue) == 0:
      system_idle_time+=1
      if i>=cumu_arrival_time_int[arv_k]:
        queue.append(cumu_arrival_time_int[arv_k])
        arv_k+=1
      continue

    server_2 = i + service_time_int2[serv2_k]
    cust_waiting_time += i + service_time_int2[serv2_k] - queue.pop(0)
    serv2_k+=1

  if i>=cumu_arrival_time_int[arv_k]:
    queue.append(cumu_arrival_time_int[arv_k])
    arv_k+=1

  if len(queue) == 0:
    system_idle_time+=1

  if arv_k >= len(cumu_arrival_time_int) - 1:
    break

print(system_idle_time, system_idle_time/seconds)
print(cust_waiting_time, cust_waiting_time/seconds)

μ = service_time
λ = arrival_rate
ρ = λ / (2 * μ)
λ_eff =  λ * (1 + ρ)


W_q = ρ**2 / (2 * μ * (1 - ρ))
W = W_q + (1 / μ)
W_s = (1 / μ) - (ρ / (2 * μ * (1 - ρ)))

print(W, W_s)

"""Regression"""

import matplotlib.pyplot as plt
from scipy import stats

x = [5,7,8,7,2,17,2,9,4,11,12,9,6]
y = [99,86,87,88,111,86,103,87,94,78,77,85,86]

slope, intercept, r, p, std_err = stats.linregress(x, y)

def myfunc(x):
  return slope * x + intercept

mymodel = list(map(myfunc, x))

plt.scatter(x, y)
plt.plot(x, mymodel)
plt.show()

import numpy
from sklearn.metrics import r2_score

x = [1,2,3,5,6,7,8,9,10,12,13,14,15,16,18,19,21,22]
y = [100,90,80,60,60,55,60,65,70,70,75,76,78,79,90,99,99,100]

mymodel = numpy.poly1d(numpy.polyfit(x, y, 3))
yx = []
xx=[]
for i in range(0, len(y)+10):
  xx.append(i+1)
  yx.append(mymodel(i))

plt.plot(x, y, c='r')
plt.plot(xx, yx, c='g')